name: Deployment

on:
  workflow_dispatch:
    inputs:
      tag:
        description: Docker image tag (e.g., v1.2.3)
        required: true
        default: staging
      environment:
        description: Environment to deploy to (e.g., staging, production)
        required: true
        default: staging
        type: choice
        options:
          - staging
          - production
      branch_or_pr:
        description: Branch name or PR number to deploy from
        required: false
        default: master


permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: write
  deployments: write
  checks: write
  packages: write
  pages: write
  discussions: write

env:
  REGISTRY: docker.io
  IMAGE_NAME: ploscope

jobs:
  deploy:
    name: Deploy (Staging/Production)
    runs-on: ${{ vars.GHA_RUNNER }}
    timeout-minutes: 5
    environment: ${{ github.event.inputs.environment }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.event.inputs.branch_or_pr || 'master' }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate branch for production
        if: github.event.inputs.environment == 'production'
        run: |
          BRANCH="${{ github.event.inputs.branch_or_pr || 'master' }}"
          if [ "$BRANCH" != "master" ]; then
            echo "âŒ Production deployments can only be made from the 'master' branch"
            echo "Current branch: $BRANCH"
            exit 1
          fi
          echo "âœ… Production deployment validated - using master branch"

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then echo "Missing required secret: SSH_PRIVATE_KEY"; exit 1; fi
          if [ -z "${{ secrets.SSH_HOST }}" ]; then echo "Missing required secret: SSH_HOST"; exit 1; fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then echo "Missing required secret: SSH_USER"; exit 1; fi
          if [ -z "${{ secrets.APP_PATH }}" ]; then echo "Missing required secret: APP_PATH"; exit 1; fi

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Determine version and branch
        id: version
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          BRANCH_OR_PR="${{ github.event.inputs.branch_or_pr || 'master' }}"
          MANUAL_TAG="${{ github.event.inputs.tag }}"

          echo "âœ… Using branch name directly: $BRANCH_OR_PR"
          DEPLOY_BRANCH="$BRANCH_OR_PR"

          if [ "$ENVIRONMENT" = "production" ]; then
            if [ -z "$MANUAL_TAG" ]; then
              echo "For production deployments, you must provide the image tag via the 'tag' input (e.g., 1.2.3)."
              exit 1
            fi
            echo "TAG=$MANUAL_TAG" >> $GITHUB_OUTPUT
            echo "DEPLOY_BRANCH=master" >> $GITHUB_OUTPUT
          else
            # Staging deployment
            if [ -n "$MANUAL_TAG" ]; then
              # Manual tag provided
              echo "TAG=$MANUAL_TAG" >> $GITHUB_OUTPUT
              echo "DEPLOY_BRANCH=$DEPLOY_BRANCH" >> $GITHUB_OUTPUT
            else
              # Default to branch name as tag
              echo "TAG=$DEPLOY_BRANCH" >> $GITHUB_OUTPUT
              echo "DEPLOY_BRANCH=$DEPLOY_BRANCH" >> $GITHUB_OUTPUT
            fi
          fi

          echo "Using tag: ${{ steps.version.outputs.TAG }}"
          echo "Deploying from branch: ${{ steps.version.outputs.DEPLOY_BRANCH }}"

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3

        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          allenvs: true
          script: |
            set -e
            echo "ğŸš€ Deploying backend..."

            # Set environment variables directly in the SSH session
            export APP_PATH=~/ploscope/backend
            export ENVIRONMENT=${{ inputs.environment }}
            export REF_NAME="${{ github.ref_name }}"
            export REF_TYPE="${{ github.ref_type }}"

            export NEXUS_PYPI_USERNAME=${{ secrets.NEXUS_PYPI_USERNAME }}
            export NEXUS_PYPI_PASSWORD=${{ secrets.NEXUS_PYPI_PASSWORD }}
            export PIP_INDEX_URL=${{ secrets.PIP_INDEX_URL }}
            export PIP_TRUSTED_HOST=${{ secrets.PIP_TRUSTED_HOST }}

            export APP_NAME=backend

            mkdir -p ~/ploscope

            export APP_PATH=${{ secrets.APP_PATH }}
            export DATABASE_URL=${{ secrets.DATABASE_URL }}
            export JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            export POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            export POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            export RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}
            export SECRET_KEY=${{ secrets.SECRET_KEY }}

            export BUILD_ENV="production"

            export POSTGRES_DB=${{ vars.POSTGRES_DB }}
            export POSTGRES_HOST=${{ vars.POSTGRES_HOST }}
            export POSTGRES_PORT=${{ vars.POSTGRES_PORT }}
            export RABBITMQ_HOST=${{ vars.RABBITMQ_HOST }}
            export RABBITMQ_PORT=${{ vars.RABBITMQ_PORT }}
            export RABBITMQ_VHOST=${{ vars.RABBITMQ_VHOST }}
            export RABBITMQ_USERNAME=${{ vars.RABBITMQ_USERNAME }}
            export RESTART_POLICY=${{ vars.RESTART_POLICY }}
            export VOLUME_MODE=${{ vars.VOLUME_MODE }}

            export WEBSOCKET_CORS_ORIGINS=${{ vars.WEBSOCKET_CORS_ORIGINS }}
            export GOOGLE_CLIENT_ID=${{ vars.GOOGLE_CLIENT_ID }}
            export GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}

            export STRIPE_SECRET_KEY=sk_test_your_staging_stripe_secret_key
            export STRIPE_PUBLISHABLE_KEY=pk_test_your_staging_stripe_publishable_key
            export STRIPE_WEBHOOK_SECRET=whsec_your_staging_webhook_secret
            export STRIPE_PRICE_PRO_MONTHLY=price_test_pro_monthly
            export STRIPE_PRICE_PRO_YEARLY=price_test_pro_yearly
            export STRIPE_PRICE_ELITE_MONTHLY=price_test_elite_monthly
            export STRIPE_PRICE_ELITE_YEARLY=price_test_elite_yearly


            # Check if the Docker network 'plo-network-cloud' exists, create if not
            if ! docker network inspect plo-network-cloud >/dev/null 2>&1; then
              echo "ğŸ”— Creating Docker network plo-network-cloud with subnet 172.30.1.0/24..."
              docker network create --subnet=172.30.1.0/24 plo-network-cloud
            else
              echo "ğŸ”— Docker network plo-network-cloud already exists."
            fi

            if [ ! -d "$HOME/ploscope/$APP_NAME/.git" ]; then
              echo "ğŸ“¥ Repository doesn't exist, cloning..."
              cd ~/ploscope
              git clone git@github.com:ploscope/$APP_NAME.git
              cd $APP_NAME
              git fetch --prune --tags origin
              git checkout ${{ steps.version.outputs.DEPLOY_BRANCH }}
              git pull origin ${{ steps.version.outputs.DEPLOY_BRANCH }}
            else
              echo "ğŸ“‚ Repository exists, pulling latest changes..."
              cd ~/ploscope/$APP_NAME
              git fetch --prune --tags origin
              git checkout ${{ steps.version.outputs.DEPLOY_BRANCH }}
              git pull origin ${{ steps.version.outputs.DEPLOY_BRANCH }}
            fi

            echo "ğŸ”§ Starting Docker Compose..."
            docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_TOKEN }} docker.io
            IMAGE_TAG="${{ steps.vars.outputs.TAG }}" docker compose pull
            IMAGE_TAG="${{ steps.vars.outputs.TAG }}" docker compose up -d

            # Wait for the $APP_NAME container to become healthy before exiting
            echo "â³ Waiting for $APP_NAME container to become healthy..."

            for i in {1..30}; do
              STATUS=$(docker inspect --format='{{.State.Health.Status}}' $APP_NAME-${{ inputs.environment }} 2>/dev/null || echo "notfound")
              if [ "$STATUS" = "healthy" ]; then
                echo "âœ… $APP_NAME container is healthy."
                echo "ğŸ“‹ Health check logs:"
                docker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' $APP_NAME-${{ inputs.environment }} || echo "Could not retrieve health logs"
                break
              elif [ "$STATUS" = "unhealthy" ]; then
                echo "âŒ $APP_NAME container is unhealthy."
                echo "ğŸ“‹ Container logs:"
                docker logs $APP_NAME-${{ inputs.environment }} --tail 50 || echo "Could not retrieve logs"
                echo "ğŸ“‹ Health check logs:"
                docker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' $APP_NAME-${{ inputs.environment }} || echo "Could not retrieve health logs"
                echo "ğŸ“‹ Health check details:"
                docker inspect --format='{{json .State.Health}}' $APP_NAME-${{ inputs.environment }} | jq '.' || echo "Could not retrieve health details"
                exit 1
              elif [ "$STATUS" = "notfound" ]; then
                echo "âŒ $APP_NAME container is not found."
                echo "ğŸ“‹ Available containers:"
                docker ps -a || echo "Could not list containers"
                exit 1
              else
                echo "â³ Waiting for health status... (current: $STATUS)"
                # Show health check logs even while starting
                if [ "$STATUS" != "starting" ]; then
                  echo "ğŸ“‹ Recent health check logs:"
                  docker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' $APP_NAME-${{ inputs.environment }} 2>/dev/null || echo "No health logs available yet"
                fi
              fi

              sleep 1
              if [ $i -eq 30 ]; then
                echo "âŒ Timeout waiting for $APP_NAME container to become healthy."
                echo "ğŸ“‹ Container logs:"
                docker logs $APP_NAME-${{ inputs.environment }} --tail 50 || echo "Could not retrieve logs"
                echo "ğŸ“‹ Health check logs:"
                docker inspect --format='{{range .State.Health.Log}}{{.Output}}{{end}}' $APP_NAME-${{ inputs.environment }} || echo "Could not retrieve health logs"
                echo "ğŸ“‹ Health check details:"
                docker inspect --format='{{json .State.Health}}' $APP_NAME-${{ inputs.environment }} | jq '.' || echo "Could not retrieve health details"
                echo "ğŸ“‹ Manual health check test:"
                docker exec $APP_NAME-${{ inputs.environment }} python /app/health_check.py || echo "Could not run manual health check"
                exit 1
              fi
            done

            echo "ğŸ‰ Deployment completed successfully!"